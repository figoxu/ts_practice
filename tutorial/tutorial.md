# TypeScript 实战教程

## 通过实例快速掌握 TypeScript

### 基础特性实战
1. **数据处理管道**
   - 基础类型实战：创建数据转换函数
   - 数组操作：实现 map, filter, reduce 的类型安全版本
   - 元组应用：实现坐标转换系统
   - 实战要点：类型推断、联合类型、类型断言

2. **配置管理器**
   - 接口设计：创建强类型的配置对象
   - 可选属性：处理可选配置项
   - 只读属性：防止配置被意外修改
   - 实战要点：接口继承、类型合并、索引签名

3. **事件发布订阅系统**
   - 函数类型：定义事件处理器
   - 泛型应用：创建通用事件总线
   - 类型约束：限制事件类型
   - 实战要点：函数重载、泛型约束、this 类型

### 进阶特性实战
4. **状态机实现**
   - 枚举和联合类型：定义状态和事件
   - 类型守卫：状态检查和转换
   - 映射类型：状态转换映射表
   - 实战要点：类型收窄、条件类型、映射类型

5. **数据验证器**
   - 类型工具：Partial、Required、Pick、Record
   - 泛型约束：验证规则定义
   - 条件类型：动态验证规则
   - 实战要点：工具类型、类型推导、类型体操

6. **API 请求库封装**
   - Promise 与异步：类型安全的请求函数
   - 泛型接口：通用响应类型
   - 错误处理：类型化的错误系统
   - 实战要点：异步类型、错误类型、响应类型

### 高级特性实战
7. **依赖注入容器**
   - 装饰器应用：服务注册与注入
   - 反射元数据：类型信息收集
   - 类型注册表：服务管理
   - 实战要点：装饰器模式、元数据、依赖注入

8. **响应式状态管理**
   - 代理和观察者：响应式数据包装
   - 类型推导：自动类型推断
   - 不可变性：只读类型和深度只读
   - 实战要点：Proxy 类型、递归类型、只读类型

9. **构建 DSL**
   - 链式调用：流畅接口设计
   - 方法装饰器：语法糖实现
   - 类型推导：上下文类型
   - 实战要点：方法链、类型流动、构建器模式

### 实战项目
10. **类型安全的表单构建器**
    - 表单配置类型定义
    - 验证规则类型系统
    - 表单状态管理
    - 实战要点：复杂类型构建、类型验证、状态管理

11. **TypeScript 版 Redux**
    - Action 类型定义
    - Reducer 类型安全
    - 状态派生和选择器
    - 实战要点：状态管理、类型推导、中间件类型

每个实例都包含：
- 完整的代码实现
- 类型设计思路
- 常见陷阱提醒
- 实际应用场景

## 学习建议
- 每个示例都可以独立运行和测试
- 建议按顺序学习，后面的示例会用到前面的概念
- 每个示例都包含单元测试，帮助理解预期行为
- 鼓励修改和扩展示例来加深理解

## 推荐练习方式
1. 先运行示例理解功能
2. 阅读类型定义理解设计
3. 尝试修改或扩展功能
4. 实现类似的自己的版本

让我们开始动手实践吧！每个示例都是一个小型但完整的项目，通过实现这些项目，您将掌握 TypeScript 的核心特性和最佳实践。

## TypeScript 命名规范

### 文件命名规范
1. **基本原则**
   - 优先使用 `kebab-case`（推荐）：`my-component.ts`
   - 或使用 `camelCase`：`myComponent.ts`
   - 避免使用下划线 `_`
   - 使用小写字母
   - 使用描述性名称

2. **特殊文件命名约定**
   - 测试文件：`*.test.ts` 或 `*.spec.ts`
   - 类型定义文件：`*.d.ts`
   - 常量文件：`*.constants.ts`
   - 工具函数：`*.utils.ts`
   - 组件文件：`*.component.ts`
   - 服务文件：`*.service.ts`

3. **目录命名**
   - 使用 `kebab-case`
   - 使用小写字母
   - 使用描述性名称
   - 避免使用特殊字符

### 代码命名规范
1. **变量和函数**
   - 使用 `camelCase`：`firstName`, `calculateTotal()`
   - 使用描述性名称
   - 布尔值前缀使用 `is`, `has`, `should` 等：`isValid`, `hasPermission`

2. **类和接口**
   - 使用 `PascalCase`：`UserService`, `DataModel`
   - 接口名可以使用 `I` 前缀（可选）：`IUserService`
   - 类型名使用 `PascalCase`：`UserType`, `ConfigOptions`

3. **常量**
   - 使用 `UPPER_SNAKE_CASE`：`MAX_COUNT`, `API_BASE_URL`
   - 对象常量使用 `PascalCase`：`DefaultConfig`

4. **枚举**
   - 枚举名使用 `PascalCase`：`UserRole`, `HttpStatus`
   - 枚举值使用 `PascalCase`：`UserRole.Admin`, `HttpStatus.NotFound`

### 最佳实践
1. **一致性原则**
   - 在整个项目中保持一致的命名风格
   - 遵循团队或项目已有的命名约定
   - 使用 `.editorconfig` 和 `eslint` 强制执行规范

2. **避免的做法**
   - 混合使用不同的命名风格
   - 使用无意义的名称（如 `a`, `b`, `foo`）
   - 使用特殊字符（除了规定的连字符和下划线）
   - 使用过于简短或难以理解的缩写

3. **注释和文档**
   - 使用 JSDoc 风格的注释
   - 为公共 API 提供完整的类型注释
   - 为复杂的类型定义添加说明性注释
